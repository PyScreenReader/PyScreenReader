"""
Script to generate Python stubs (.pyi) and reStructuredText (.rst) documentation
from PyScreenReader wheels or existing stub directories.

Usage
-----

    $ bazel //tools:generate_doc -- <input_path> [--stub] [--doc]

Arguments
---------

- input_path
  Path to a wheel file (when generating stubs) or a directory containing
  existing stubs (when generating docs only).

Options
-------

- -s, --stub
  Generate stub (.pyi) files from the given wheel. The wheel will be
  installed in a temporary directory and `pybind11-stubgen` will be used
  to create the stubs, which are then copied into `src/stubs`.

- -d, --doc
  Generate RST documentation from stub (.pyi) files. Each class defined in
  the stubs will have a dedicated `.rst` file created under
  `doc/source/reference`.

Dependencies
------------

- pybind11-stubgen (for stub generation)
- pip (to install the wheel into a temporary directory)

Examples
--------

Generate both stubs and docs from a wheel::

    $ bazel //tools:generate_doc -- dist/PyScreenReader-0.1.0-py3-none-any.whl --stub --doc

Generate only docs from an existing stub directory::

    $ bazel //tools:generate_doc -- src/stubs --doc
"""

import argparse
import ast
import os
import re
import shutil
import subprocess
import sys
import tempfile
import textwrap
from glob import glob
from pathlib import Path

from pybind11_stubgen import main as stubgen_main


PYI_FILE_SUFFIX = ".pyi"
MODULE_NAME = "PyScreenReader"

BAZEL_WORKSPACE_ENV_KEY = "BUILD_WORKSPACE_DIRECTORY"
SOURCE_CODE_ROOT = Path(os.environ.get(BAZEL_WORKSPACE_ENV_KEY, Path.cwd()))
STUB_OUTPUT_DIR = SOURCE_CODE_ROOT / "src" / "stubs"
DOC_OUTPUT_DIR = SOURCE_CODE_ROOT / "doc" / "source" / "reference"

SKIP_PYTHON_MODULES = frozenset(("__init__",))

GENERATED_DOC_HEADER = ".. This file is auto-generated by //tools:generate_doc. Please do not edit directly"


def camel_to_snake_case(name: str) -> str:
    """Convert camel case to snake case.

    For example: VirtualWidget -> virtual_widget
    :param name: camel case name
    :return: lower snake case
    """
    return re.sub(r"(?<!^)(?=[A-Z])", "_", name).lower()


def format_function_signature(func: ast.FunctionDef) -> str:
    """Formats function signature of the given function definition.

    :param func: function definition
    :return: formatted function signature
    """
    args = []
    for arg in func.args.args:
        if arg.arg != "self":
            args.append(arg.arg)
    arglist = ", ".join(args)
    returns = ""
    if func.returns and hasattr(ast, "unparse"):
        returns = f" -> {ast.unparse(func.returns)}"
    return f".. method:: {func.name}({arglist}){returns}"


def extract_docstring(
    node: ast.AsyncFunctionDef | ast.FunctionDef | ast.Module | ast.ClassDef,
) -> str:
    """Extracts docstrings from the given AST node.

    :param node: an AST node of Async Function, Function Definition, Module, or a Class Definition.
    :return: doc string
    """
    docstring = ast.get_docstring(node)
    if docstring:
        return textwrap.indent(docstring.strip(), "   ")
    return ""


def process_class(cls: ast.ClassDef, output_dir: str) -> None:
    """Generate documentation for a given class

    :param cls: given class
    :param output_dir: directory to store the rst documentation
    """
    class_name = cls.name
    filename = camel_to_snake_case(class_name) + ".rst"
    filepath = os.path.join(output_dir, filename)

    lines = [f"{GENERATED_DOC_HEADER}\n", f".. class:: {class_name}", ""]

    # Class docstring
    class_doc = extract_docstring(cls)
    if class_doc:
        lines.append(class_doc)
        lines.append("")

    # Inheritance information
    if cls.bases:
        base_names = []
        for base in cls.bases:
            if isinstance(base, ast.Name):
                base_names.append(base.id)
            elif isinstance(base, ast.Attribute):
                base_names.append(ast.unparse(base) if hasattr(ast, "unparse") else "<unknown>")
        if base_names:
            lines.append(f"   Inherited from {', '.join(base_names)}")
            lines.append("")

    for item in cls.body:
        if isinstance(item, ast.FunctionDef):
            lines.append("   " + format_function_signature(item))
            doc = extract_docstring(item)
            if doc:
                lines.append("")
                lines.append(doc)
                lines.append("")

    with open(filepath, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    print(f"Generated doc: {filepath.replace(str(DOC_OUTPUT_DIR), '')}")


def generate_rst(stub_dir: str = STUB_OUTPUT_DIR, output_dir: str = DOC_OUTPUT_DIR) -> None:
    """Generate reStructuredText (rst) documentation from given pyi file

    :param stub_dir pyi files input dir
    :param output_dir: save path for generated rst files
    """
    for pyi_file in glob(os.path.join(stub_dir, f"*{PYI_FILE_SUFFIX}"), recursive=False):
        if Path(pyi_file).stem in SKIP_PYTHON_MODULES:
            continue

        with open(pyi_file, encoding="utf-8") as f:
            source = f.read()

        tree = ast.parse(source, pyi_file)

        # Create a subfolder for each module
        module_output_dir = os.path.join(output_dir, Path(pyi_file).stem)
        if not os.path.exists(module_output_dir):
            os.makedirs(module_output_dir)

        for node in tree.body:
            if isinstance(node, ast.ClassDef):
                process_class(node, module_output_dir)


def generate_pyi(wheel_path: str, output_dir: str = STUB_OUTPUT_DIR) -> None:
    """Generate Python stub (pyi) files from the given wheel

    :param wheel_path: path to the python wheel
    :param output_dir: pyi files output directory
    """
    wheel_path = os.path.expanduser(wheel_path)
    output_dir = os.path.expanduser(output_dir)

    with tempfile.TemporaryDirectory() as tmp_install_dir:
        subprocess.check_call(
            [
                sys.executable,
                "-m",
                "pip",
                "install",
                wheel_path,
                "--force-reinstall",
                "--target",
                tmp_install_dir,
            ],
        )

        # add the temp install directory to sys.path to make the wheel importable
        sys.path.insert(0, tmp_install_dir)

        stubgen_main(
            [
                MODULE_NAME,
                "--output-dir",
                tmp_install_dir,
            ],
        )

        for pyi_file in glob(
            os.path.join(tmp_install_dir, MODULE_NAME, f"*{PYI_FILE_SUFFIX}"),
            recursive=False,
        ):
            shutil.copy(pyi_file, output_dir)
            print(f"Generated stub: {os.path.basename(pyi_file)}")

        # recover sys.path
        sys.path.pop(0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "input_path",
        help="Input path (can be a wheel for stub and doc generation, or a dir of stubs just for doc generation)",
    )
    parser.add_argument(
        "-s", "--stub", action="store_true", help="Generate stubs (default to False)"
    )
    parser.add_argument("-d", "--doc", action="store_true", help="Generate docs (default to False)")
    args = parser.parse_args()

    input_path = Path.expanduser(Path(args.input_path))
    if not Path.exists(input_path):
        error_msg = "Given input path does not exist."
        raise RuntimeError(error_msg)

    if not Path.is_file(input_path) and args.stub:
        error_msg = "The input path for stub generation should be a path pointing to a wheel."
        raise RuntimeError(error_msg)

    if not Path.is_dir(input_path) and args.doc and not args.stub:
        error_msg = (
            "The input path for doc generation (only) should be a folder containing python stubs."
        )
        raise RuntimeError(error_msg)

    if not args.stub and not args.doc:
        print("Nothing to do. Use --stub and/or --doc.")
        exit(1)

    if args.stub:
        # Generate stubs from wheel to STUB_OUTPUT_DIR
        generate_pyi(str(input_path))

    if args.doc:
        stub_source_dir = (
            str(input_path) if Path.is_dir(input_path) and not args.stub else str(STUB_OUTPUT_DIR)
        )
        generate_rst(stub_dir=stub_source_dir, output_dir=str(DOC_OUTPUT_DIR))
